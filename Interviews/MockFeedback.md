# Dec 4th 

## What are the layers of the Neiman Marcus app? From API to UI, what are the components in between and how do they interact?
- API layer 
  - Retrofit + OkHttp client for network calls
  - DTO data models mapped to backend contracts (pricing, inventory, personalization)
- Data layer
  - Repository pattern coordinating remote + local data
  - Data sources
    - Remote: Retrofit services for product catalog, pricing, inventory, recommendations
    - Local: Room/SQL cache for product list, recently viewed items, and user preferences
  - Mapping from network DTOs to domain models (e.g., `ProductDto` → `Product`)
- Domain layer
  - Use cases encapsulating business logic
    - e.g., `GetPersonalizedFeed`, `GetProductDetail`, `GetRealTimePrice`, `SearchProducts`
  - Orchestrates repositories, applies pricing/availability rules, and exposes simple results to UI
- UI layer
  - ViewModels per feature (Home, Product Detail, Bag, Account)
  - State container in each ViewModel (immutable UI state)
  - Composables rendering state and sending user intents back to the ViewModel

- weakness
  - too generic
  - make it specific to Neiman Marcus
    - personalized recommendation (products based on user behavior)
      - Used a `PersonalizedFeedRepository` that combined:
        - browsing history from local storage, and
        - recommendation results from a backend ML service
      - Domain use case `GetPersonalizedFeed` exposed a unified `Flow<PersonalizedFeedUiModel>` to the UI.
    - describe real time data processing (inventory, pricing)
      - Product detail and bag screens subscribed to a `Flow` of price/inventory updates.
      - Repository listened to backend streaming / polling endpoints and updated Room; UI observed DB via Flow.
    - offline support (local caching of user data and product catalog)
      - First load came from Room cache; background jobs refreshed catalog and user data when connectivity returned.
      - Use cases always read from local DB as single source of truth, then triggered sync.
    - high performance image loading (Coil with caching strategies)
      - Used Coil with size-aware requests (API image breakpoints) and disk+memory cache tuning to avoid decoding huge images on the main thread.
    - responsiveness under load (multiple coroutines for data fetching and UI updates)
      - ViewModels launched structured coroutines for parallel requests (pricing, inventory, recommendations) and merged results into a single UI state.
  - coroutines mentioned
  - why were these decisions made?
    - To keep the app responsive under load, we isolated I/O on `Dispatchers.IO`, UI work on `Dispatchers.Main`, and used structured concurrency in ViewModels so any failed child job was handled predictably.

- instead of LaunchedEffect -> init 
  - For screen initialization, we kept side-effects in the ViewModel `init {}` block rather than `LaunchedEffect` in the Composables.
  - This centralized structured concurrency in one place, made logic easier to test (no need to spin up Compose), and kept the UI purely declarative.

- tech feedback
  - real time inventory updates
  - price updates without jank
  - state container used inside view model
    - In each ViewModel we used a **state container**: a single immutable `UiState` data class (e.g., `HomeUiState`) exposed as a `StateFlow`.
    - The ViewModel held a private `MutableStateFlow<HomeUiState>` and only exposed `StateFlow<HomeUiState>` to the UI.
    - All events (network results, user actions, errors) produced a **new copy** of `UiState` via `copy(...)`, which kept state transitions explicit and traceable.
  - where UI had immutable UI models state management 
    - Composables collected the `StateFlow` as `state` (`collectAsState()`), and rendered based only on that immutable `UiState`.
    - Because the UI models were immutable, we avoided in-place mutation bugs, made recompositions predictable, and it was easy to debug by logging previous vs new state.
  - thread safety 
    - Exposing only immutable state to the UI and updating the `MutableStateFlow` from a single ViewModel coroutine scope kept things thread-safe.
    - Repositories used appropriate dispatchers and avoided sharing mutable objects across threads, so we didn’t need manual locks; flows and immutability handled most concurrency concerns.


## compose performance can degrade quickly with heavy media, how did you handle stability and unnecessary recompositions in the Neiman Marcus app?
- we had this problem
- we went to diagnose it
- we implemented some changes
- we checked performance again
- what were the results?

- We had lower-end Samsung devices that were struggling with jank and frame drops when scrolling through media-heavy product lists. 
- To diagnose the issue, we used tools like Android Profiler, Macrobenchmark, and Layout Inspector to identify bottlenecks in our composables.
- We implemented several optimizations:
  - Leveraged `LazyColumn` with proper item keys to efficiently handle large lists.
    - **Stability:** Keys ensured items were reused correctly, improving scroll smoothness and reducing jank.
    - **Recompositions:** Stable keys plus stable item models reduced unnecessary recomposition when lists updated.
      - TODO: what do you mean by stable item models? like the @Stable annotation?
  - Optimized image loading with Coil, using placeholders and caching strategies to reduce load times.
    - **Stability:** Placeholders and error images prevented blank/flickering UI when network was slow or failed.
    - **Recompositions:** Size-aware requests and caching meant fewer layout changes and faster rebinds when items came back on screen.
      - TODO: how does size-aware requests cause less layout changes?
  - Paginated data loading (Paging 3) to avoid overwhelming the UI with too much data at once.
    - Paging 3 does more than `LazyColumn` alone:
      - It coordinates **data paging**, caching, and loading states (loading, error, empty) and integrates with Room.
      - It ensures that only a window of items is loaded in memory, which improves memory usage and reduces GC pressure.
    - **Stability:** Smaller in-memory windows reduced OOM risk on low-end devices.
    - **Recompositions:** Paging emits smaller, incremental updates instead of huge list changes, which reduces the work Compose has to do.
  - Minimized the use of complex layouts and deeply nested composables, simplifying the UI structure.
    - **How this helps performance:**
      - Fewer nested composables means a smaller composition tree and less work during each recomposition.
      - Layout and measure passes become cheaper, which directly reduces frame time and makes it easier to stay within the 16ms budget.
    - **Stability:** Simpler layouts are less prone to layout thrashing when data changes.
    - **Recompositions:** With a flatter tree and fewer derived values in the composition, recompositions touch less code.
- Categorized by goal:
  - **Stability / smooth scrolling:**
    - Coil optimization and correct image sizes
    - Paging 3 with smaller in-memory windows
    - Simplified layouts and reduced nesting
  - **Reducing unnecessary recompositions:**
    - Using `LazyColumn` with stable keys and stable item models
    - Avoiding heavy work inside composable functions; pushing work to ViewModel/use cases
    - Flatter composable hierarchy and memoization (`remember`) where appropriate
- We followed up by re-evaluating performance using the same profiling tools, and we observed a significant reduction in frame drops and jank during scrolling. 
  - The user experience improved notably, especially on lower-end devices.
  - On our test matrix, janky frames on older Samsung devices dropped by roughly 10–15%, and scroll felt much closer to 60fps on product-heavy screens.
