# Compose State
- Compose is a declarative UI framework
  - Instead of removing UI components or changing their visibility when state changes, we describe how the UI is under specific conditions of state.
- Key idea: If the UI is what the user sees, the UI state is what the app says they should see.

- You can inspect the app layout generated by Compose using Android Studio's Layout inspector tool, 
  - Tools > Layout Inspector.
  - To see Compose nodes in the Inspector, use a device with API >= 29

- A composable that uses remember to store an object contains internal state, which makes the composable stateful.
  - composables with internal state tend to be less reusable and harder to test.

## Stateless vs Stateful
- **Stateless**: A composable that does not hold any state internally. It receives all necessary data and event handlers via parameters. This makes it reusable and easier to test.
- **Stateful**: A composable that manages its own state internally. It can use `remember` and `mutableStateOf` to hold state that survives recompositions.
- **Best Practice**: Prefer stateless composables and lift state up to the nearest common ancestor. This improves reusability and makes state management clearer.
- Example:
```kotlin
@Composable
fun StatelessCounter(count: Int, onIncrement: () -> Unit) {
    Button(onClick = onIncrement) {
        Text("Count: $count")
    }
}
@Composable
fun StatefulCounter() {
    var count by remember { mutableStateOf(0) }
    StatelessCounter(count = count, onIncrement = { count++ })
}
```


## remember and mutableStateOf
- `remember`: Used to store a single object in memory during recompositions. The value is retained as long as the composable is in the composition.
- `mutableStateOf`: Creates a mutable state holder. When the value changes, it triggers recomposition of any composables that read this state.
- this is at the compose level, not ViewModel level
- `by` keyword is a property delegate that allows you to read and write the value directly
- Example:
```kotlin
var count by remember { mutableStateOf(0) }
```
- Use `remember` for state that should survive recompositions but not configuration changes (like screen rotations).
- A value calculated by remember is stored in the Composition during the initial composition, and the stored value is kept across recompositions.
- You can think of using remember as a mechanism to store a single object in the Composition, in the same way a private val property does in an object.

- remember stores objects in the Composition, and forgets the object if the source location where remember is called is not invoked again during a recomposition.

- While remember helps you retain state across recompositions, it's not retained across configuration changes. For this, you must use rememberSaveable instead of remember.
  - if you change language, switch between dark and light mode, or any other configuration change that makes Android recreate the running Activity.
## rememberSaveable
- Similar to `remember`, but the state is saved and restored across configuration changes (like screen rotations).
- It uses `SavedStateHandle` under the hood to persist state.

- rememberSaveable automatically saves any value that can be saved in a Bundle. For other values, you can pass in a custom saver object
- [More Info on Restoring State](https://developer.android.com/jetpack/compose/state#restore-ui-state)

- Use rememberSaveable to restore your UI state after an Activity is recreated. Besides retaining state across recompositions, rememberSaveable also retains state across Activity recreation and system-initiated process death.

- when an item leaves the Composition, state that was remembered is forgotten. 
- For items on a LazyColumn, items leave the Composition entirely when you scroll past them and they're no longer visible.

- The composable function rememberLazyListState creates an initial state for the list using rememberSaveable. 
- When the Activity is recreated, the scroll state is maintained without you having to code anything.

- Example:
```kotlin
var text by rememberSaveable { mutableStateOf("") }
```
- Use `rememberSaveable` for small pieces of state that need to survive configuration changes (like text input).
- Example of custom saver:
```kotlin
@Composable
fun CustomSaverExample() {
    val customObjectSaver = Saver<CustomObject, String>(
        save = { it.toString() }, // Convert CustomObject to String for saving 
        restore = { CustomObject.fromString(it) } // Convert String back to CustomObject
    )
    var customObject by rememberSaveable(stateSaver = customObjectSaver) { mutableStateOf
        (CustomObject()) }
}
```


## State Hoisting
- Composables that don't hold any state are called stateless composables. An easy way to create a stateless composable is by using state hoisting.

- The general pattern for state hoisting in Jetpack Compose is to replace the state variable with two parameters:
  - value: T - the current value to display 
  - onValueChange: (T) -> Unit - an event that requests the value to change with a new value T

- The pattern where the state goes down, and events go up is called Unidirectional Data Flow (UDF), and state hoisting is how we implement this architecture in Compose.
  - [Learn More](https://developer.android.com/jetpack/compose/architecture#udf-compose)

- State that is hoisted this way has some important properties:
  - **Single source of truth**: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs. 
  - **Shareable**: Hoisted state can be shared with multiple composables. 
  - **Interceptable**: Callers to the stateless composables can decide to ignore or modify events before changing the state. 
  - **Decoupled**: The state for a stateless composable function can be stored anywhere. For example, in a ViewModel.


- The practice of moving state up to a common ancestor (parent) so that it can be shared among multiple composables.
- This makes the state management clearer and improves reusability of stateless composables.
- Should take care to avoid unnecessary recompositions by keeping state as close to where it's used as possible.
  - we don't want to reload the entire list if only one item changes or recomposing the entire screen if only one button is clicked
- Example:
```kotlin
@Composable
fun Parent() {
    var count by remember { mutableStateOf(0) }
    Child(count = count, onIncrement = { count++ })
}
@Composable
fun Child(count: Int, onIncrement: () -> Unit) {
    Button(onClick = onIncrement) {
        Text("Count: $count")
    }
}
```

## ViewModel and StateFlow
- Use `ViewModel` to hold UI state that should survive configuration changes.
- Use `StateFlow` or `LiveData` in the ViewModel to expose state to the UI.
  - Prefer `StateFlow` for new code as it is more powerful and flexible.
  - `StateFlow` is a part of Kotlin Coroutines and provides a way to manage and observe state in a reactive way.
  - `LiveData` is lifecycle-aware and works well with traditional Android components, but `StateFlow` integrates better with Compose.
- Collect `StateFlow` in a composable using `collectAsState()` to observe state changes and trigger recompositions.
- `MutableStateFlow` is used to create a mutable state holder in the ViewModel. The UI should only see the immutable `StateFlow` to prevent direct modifications.

- Note: You might already be using other observable types like LiveData, StateFlow, Flow, and RxJava's Observable to store state in an app. 
- To allow Compose to use this state and automatically recompose when the state changes you need to map them to a State<T>.

- WARNING: ViewModels are not part of the Composition. 
- Therefore, you should not hold state created in composables (for example, a remembered value) because this could cause memory leaks.

- it's a good practice to keep the UI logic and business logic separated from the UI state and migrate it to a ViewModel.

- viewModel() returns an existing ViewModel or creates a new one in the given scope
- The ViewModel instance is retained as long as the scope is alive. 
- For example, if the composable is used in an activity, viewModel() returns the same instance until the activity is finished or the process is killed.

- ViewModels are recommended to be used at screen-level composables, that is, close to a root composable called from an activity, fragment, or destination of a Navigation graph. 
- ViewModels should never be passed down to other composables, instead you should pass only the data they need and functions that perform the required logic as parameters.

- Example:
```kotlin
class MyViewModel : ViewModel() {
    private val _count = MutableStateFlow(0)
    val count: StateFlow<Int> = _count.asStateFlow()
    fun increment() { _count.value++ }
    
    funUpdateCount() {
        _count.update { it + 1 } // atomic update -> background thread safe
        _count.value += 1 // not atomic -> main thread only
    }
}
@Composable
fun MyScreen(viewModel: MyViewModel = viewModel()) {
    val count by viewModel.count.collectAsState()
    Button(onClick = { viewModel.increment() }) {
        Text("Count: $count")
    }
}
```
```kotlin
class ThisViewModel : ViewModel() {
    private val _myList = MutableLiveData<MyListData>()
    val myList: LiveData<MyListData> = _myList
    
    // priority -> on main thread
    _myList.value = repository.getData() // update the list
    // background thread
    _myList.postValue(repository.getData()) // update the list
    
}
```

## Mutable and Observable State
- Using mutable objects for this, such as ArrayList<T> or mutableListOf, won't work. 
  - These types won't notify Compose that the items in the list have changed and schedule a recomposition of the UI

- You need to create an instance of MutableList that is observable by Compose
- The extension function toMutableStateList() is the way to create an observable MutableList from an initial mutable or immutable Collection, such as List.
- Alternatively, you could also use the factory method mutableStateListOf to create the observable MutableList

- The mutableStateOf function returns an object of type MutableState<T>. 
- The mutableStateListOf and toMutableStateList functions return an object of type SnapshotStateList<T>.

- WARNING: You can use the mutableStateListOf API instead to create the list. 
- However, the way you use it might result in unexpected recomposition and suboptimal UI performance. 
- If you just define the list and then add the tasks in a different operation it would result in duplicated items being added for every recomposition.

```kotlin
// Don't do this!
val list = remember { mutableStateListOf<WellnessTask>() }
list.addAll(getWellnessTasks())


// Instead, create the list with its initial value in a single operation and then pass it to the remember function, like this:
// Do this instead. Don't need to copy
val list = remember {
    mutableStateListOf<WellnessTask>().apply { addAll(getWellnessTasks()) }
}
```
